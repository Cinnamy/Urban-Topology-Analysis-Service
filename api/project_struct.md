# Структура серверной части сервиса

## api
### cities_osm
1) [osm_handler.py](./cities_osm/osm_handler.py) - парсинг дорог из osm-файлов
2) [osmfetch.py](./cities_osm/osmfetch.py) - содержит функции для скачивания osm-файлов
*В этой же директории должны содержаться скачанные osm-файлы
fastapi_service
### data - директория содержит .csv и .json файлы со свойствами представленных городов 
1) [database.py](./data/database.py) - содержит определение БД 
2) [main.py](./data/main.py) - главный файл, содержит реализацию запросов
3) [models.py](./data/models.py) - содержит определения классов для взаимодействия с БД 
4) [osm_handler.py](./data/osm_handler.py) - дубликат
5) [schemas.py](./data/schemas.py) -  содержит определения вспомогательных классов 
6) [services.py](./data/services.py) - содержит определения вспомогательных функций
7) [street_name_parser.py](./data/street_name_parser.py) - содержит определение парсера
### [Dockerfile](./Dockerfile)
### [requirements.txt](./requirements.txt)
### [docker-compose.yaml](./docker-compose.yaml)

	

## Полное описание файлов

### osm_handler.py:
Этот код извлекает данные о дорогах и узлах из файла OSM и сохраняет их в CSV-файлах.

Сначала определяются два класса: HighwayWaysHandler и HighwayNodesHandler. Эти классы являются обработчиками, которые будут использоваться для обработки данных о дорогах и узлах соответственно.

Затем функция parse_osm использует класс HighwayWaysHandler, чтобы извлечь информацию о дорогах и сохранить ее в словаре ways_tags. Затем класс HighwayNodesHandler используется для извлечения информации об узлах из того же файла OSM и сохранения их в словаре nodes_tags. Обработанные данные возвращаются как два словаря.

После этого данные сохраняются в двух CSV-файлах: "nodes.csv" и "graph.csv", с помощью функции to_csv. Функция использует словари ways_tags и nodes_tags, созданные в parse_osm, для создания двух таблиц: одна таблица содержит информацию об узлах, а другая таблица содержит информацию о дорогах и их именах.

### osmfetch.py:
Этот код содержит две функции osmfetch() и download_city(), которые используются для загрузки данных с карты OpenStreetMap.

Функция osmfetch() использует API Overpass для загрузки данных о местности в формате OSM (OpenStreetMap) с использованием границ (bbox), заданных в параметрах функции. Для расширения границ можно использовать параметр expansion. Функция возвращает путь к файлу OSM, сохраненному в директории save_directory.

Функция download_city() использует библиотеку OSMnx для получения географических координат города city_name. Затем функция использует полученные координаты для вызова функции osmfetch() и загрузки данных в формате OSM. Функция возвращает путь к загруженному файлу OSM.

Обе функции используют библиотеку requests для отправки HTTP-запросов к серверу OSM API и получения ответа в виде текстового файла, который затем сохраняется в файл OSM на локальном диске.

### database.py:
Файл содержит код, который является настройками для работы с базой данных, используя библиотеки SQLAlchemy и databases.

С помощью библиотеки SQLAlchemy определены таблицы и их поля в базе данных. Эти таблицы представлены объектами Table. Для каждой таблицы определены колонки (Column) с их типами данных, ограничениями и свойствами. Некоторые поля имеют связи (ForeignKey) с другими таблицами.

Также определен объект metadata, который содержит метаданные таблиц.

Код создает несколько таблиц для базы данных:

CityAsync: таблица для хранения данных о городе: идентификатор, идентификатор свойства, название города и флаг, указывающий, были ли загружены данные.

PropertyAsync: таблица для хранения данных свойств: идентификатор и имя свойства.

CityPropertyAsync: таблица для хранения данных о свойствах города: идентификатор, широту и долготу, идентификатор района, идентификатор начального полигона, данные о населении, данные о плотности населения, данные о часовом поясе и данные о времени создания.

PointAsync: таблица для хранения данных точек: идентификатор, долготу и широту.

WayAsync: таблица для хранения данных пути: идентификатор, идентификатор города и ограничение внешнего ключа для таблицы Cities.

WayPropertyAsync: таблица для хранения данных свойств пути: идентификатор, идентификатор пути, идентификатор свойства и значение свойства.

EdgesAsync: таблица для хранения данных о границе: идентификатор, идентификатор пути, идентификатор исходной точки и идентификатор точки назначения.

PointPropertyAsync: таблица для хранения данных свойств точки: идентификатор, идентификатор точки, идентификатор свойства и значение свойства.

Создано подключение к базе данных (DATABASE_URL) с помощью функции create_engine. Создан объект базы данных Database.

Для работы с базой данных также используется объект сессии (SessionLocal), который позволяет выполнять транзакции и запросы к базе данных.

Определен базовый класс (Base), который позволяет создавать классы, соответствующие таблицам базы данных, для работы с ORM SQLAlchemy.


### logs.py:
Код создает логгер для записи и отображения логов в проекте с помощью библиотеки loguru.

Импортируется модуль sys и функция logger из библиотеки loguru.

В функции init() задается формат лога и создаются три обработчика логов, которые позволяют выводить сообщения разного уровня на экран, а также записывать логи в файл "logs.log".

Первый обработчик отвечает за вывод ошибок в стандартный поток ошибок sys.stderr.

Второй обработчик выводит информационные сообщения в стандартный поток вывода sys.stdout.

Третий обработчик записывает логи в файл "logs.log" с учетом заданного формата, а также настройки rotation и retention для ограничения размера лог-файла.

В конце функция возвращает объект логгера, который может использоваться для записи и отображения логов в проекте.

### main.py:
Данный код описывает веб-приложение на основе FastAPI, предназначенное для работы с геоданными городов и регионов.

В начале кода происходит импорт необходимых библиотек и файлов, а также чтение данных о городах и регионах из файлов.

Затем создается экземпляр класса FastAPI и логгер, и устанавливается промежуточное ПО CORSMiddleware для разрешения CORS.

Далее объявляются функции-обработчики запросов, принимающие и обрабатывающие запросы на получение данных о городах и регионах и возвращающие соответствующие данные в формате JSON.

Функции-обработчики принимают различные параметры запросов, например, идентификатор города или региона, количество записей на странице и номер текущей страницы.

Также объявляются функции-обработчики запросов на создание графа города на основе заданных идентификаторов регионов или координаты границ города.

Функции-обработчики используют сервисы, определенные в файле services.py, для получения данных из базы данных и преобразования их в формат JSON.

В конце файла прописывается код для запуска приложения.

Общий алгоритм работы приложения следующий:

1) Получить запрос на определенную конечную точку API;
2) Передать запрос соответствующему обработчику;
3) Обработать запрос, используя сервисы для получения данных из базы данных;
4) Вернуть полученные данные в формате JSON.

### models.py:
Код описывает ORM-модели (Object-Relational Mapping models) для таблиц базы данных в SQLAlchemy.

ORM-модели позволяют обращаться к данным в таблицах базы данных, используя объекты Python, а не язык SQL. Кроме того, ORM-модели предоставляют множество встроенных методов для работы с данными, таких как добавление, удаление, изменение и запросы.

Определяются ORM-модели для трех таблиц: Cities, CityProperties и Points. Каждая модель определяет соответствие между классом Python и таблицей базы данных.

Модель City соответствует таблице Cities и имеет три столбца: id, id_property и city_name. Для каждого столбца определен тип данных, указано, является ли он первичным ключом (primary_key=True) и должен ли он автоматически инкрементироваться (autoincrement=True). Также определен столбец downloaded с типом Boolean и установленным значением по умолчанию (default=False), а также индекс (index=True).

Вторая модель CityProperty соответствует таблице CityProperties и имеет несколько столбцов, включая столбцы типа Float, Integer, BigInteger, VARCHAR и DateTime. Здесь также определены индексы и значение по умолчанию.

Третья модель Point соответствует таблице Points и имеет два столбца с типом данных Float.

### schemas.py:
Код определяет несколько базовых классов для создания моделей данных с помощью Pydantic (библиотека для проверки и сериализации данных в Python).

BaseModel - это базовый класс для определения моделей данных. Он используется для определения структуры и типов данных, которые ожидаются для каждого поля модели данных.

PointBase - это класс модели данных, который определяет два поля, представляющие координаты долготы и широты.

PropertyBase - это класс модели данных, который определяет несколько полей для хранения информации о свойствах населенных пунктов, таких как население, плотность населения, координаты центра населенного пункта, часовой пояс и время создания.

CityBase - это класс модели данных, который определяет поля для идентификатора города, названия города, свойств населенных пунктов, загружено ли содержание города.

RegionBase - это класс модели данных, который определяет поля для идентификатора региона, уровня административного деления, имени и географических координат этого региона.

GraphBase - это класс модели данных, который определяет несколько полей для хранения информации о графе. Он используется для определения путей к файлам csv, содержащих данные об узлах, ребрах, свойствах узлов и свойствах ребер.

### services.py:
Файл представляет собой набор вспомогательных функций для работы с графами.

get_db - создает соединение с базой данных. После выполнения блока try функция закрывает соединение с бд.
 
point_to_scheme - преобразует координаты точки в структуру, которая используется для передачи данных.

list_to_csv_str - преобразует список в строку в формате CSV, возвращает строку CSV, и объект DataFrame.

reversed_graph_to_csv_str - функция get_reversed_graph переворачивает граф, т.е. меняет направление всех ребер и возвращает DataFrame с перевернутыми ребрами, узлами и матрицей. Затем функция создает объект StringIO для каждого из  DataFrame-ов: redges_df, rnodes_df, rmatrix_df (но rmatrix_df закомментирован).

функция возвращает 3 строки: 
1) redges.getvalue() - содержащую информацию о перевернутых ребрах в формате CSV, 
2) rnodes.getvalue() - содержащую информацию об узлах в формате CSV, 
3) None - поскольку матрица не была записана.

graph_to_scheme - функция преобразует данные графа (набор точек и ребер) в формат, который может быть использован для хранения в базе данных. Она принимает на вход четыре аргумента потом преобразует каждый из этих списков в строку CSV формата. Затем она создает "обратный" граф.

В итоге функция возвращает объект GraphBase, который содержит следующие CSV-строки:
1) edges_csv: содержит список ребер графа.
2) points_csv: список точек графа.
3) ways_properties_csv: список свойств ребер графа.
4) points_properties_csv: список свойств точек графа.
5) reversed_edges_csv: список "обратных" ребер графа (ребер с инвертированными направлениями).
6) reversed_nodes_csv: список "обратных" точек графа.

property_to_scheme - преобразует экземпляр класса CityProperty в экземпляр класса PropertyBase, в котором значения полей заполнены значениями соответствующих полей экземпляра CityProperty. 

city_to_scheme - преобразует данные о городе (название города и его свойства) в структуру, которая используется для передачи данных.

cities_to_scheme_list - преобразует список городов в список структур, которые используются для передачи и хранения в базе данных.

get_cities - получает список городов из базы данных.

get_city - получает из базы данных объект City с заданным идентификатором, возвращает соответствующий объект CityBase.

add_info_to_db - функция принимает на вход DataFrame, содержащий информацию о городе. Она ищет город в базе данных, и если его там нет, то добавляет его вместе с его свойствами и id. 
Если город найден в базе данных, функция проверяет, загружены ли данные для этого города и если нет, то вызывает функцию add_graph_to_db.

add_graph_to_db - функция добавляет информацию о графах дорог и их свойствах в базу данных. 
Принимает два параметра: id города и путь к файлу, содержащему информацию об OSM-карте города.
Сначала функция использует другую функцию parse_osm для чтения файла OSM-карты города и получения информации о дорогах и их свойствах. Затем функция проходится по всем узлам и свойствам, содержащимся в файле, и добавляет их в соответствующие таблицы в базе данных.
Для каждого узла функция создает новую запись в таблице PointAsync и добавляет связь между этим узлом и его свойствами в таблице PointPropertyAsync. Если свойство уже существует, то используется его id, в противном случае создается новая запись в таблице PropertyAsync.
Затем функция проходится по всем дорогам и добавляет их в таблицу WayAsync, а также добавляет связи между дорогами и их свойствами в таблицу WayPropertyAsync. Для каждого ребра графа дорог функция создает новую запись в таблице EdgesAsync. 
Если дорога двусторонняя (не является "oneway"), то функция добавляет две записи в таблицу EdgesAsync для каждого ребра, одну для направления от узла источника к узлу назначения, и вторую для направления в обратном порядке. 
Если дорога односторонняя, то добавляется только одна запись в таблицу EdgesAsync.
В конце функция помечает город как загруженный в таблице CityAsync, и закрывает соединение с базой данных.

add_point_to_db - добавляет точку (объект Point) с координатами latitude и longitude из переданного df в базу данных. Возвращает ID добавленной точки.

add_property_to_db - добавляет информацию о городе (объект CityProperty) с координатами c_latitude и c_longitude, населением population и часовым поясом time_zone из df в базу данных. 

add_city_to_db - добавляет город (объект City) с названием city_name из df и связывает его с объектом CityProperty, имеющим переданный property_id. Возвращает ID добавленного города.

init_db - добавляет информацию о городах из cities_info в базу данных

download_info - загружает информацию о городе city, сохраняет граф дорожной сети этого города в формате .osm в файл и возвращает True. 
Если граф уже был сохранен в файле, функция возвращает True без загрузки графа повторно. 
Если город не найден, функция возвращает False.

delete_info - удаляет файл графа дорожной сети города city, если он существует, и возвращает True. Если файл не существует, функция возвращает False.

download_city - загружает данные о городе из базы данных, затем скачивает данные для этого города и сохраняет флаг загрузки.
Преобразует объект City в объект CityBase.

delete_city - удаляет загруженные данные о городе, устанавливает флаг загрузки на значение False.

to_list - преобразует объект LineString в списки координат.

to_json_array - преобразует объект LineString и MultiLineString (polygon) в списки координат, которые используются для построения границ регионов на карте.

region_to_schemas - Преобразует данные, полученные из базы данных, в объекты RegionBase. Функция используется для отображения регионов на карте.

children - ищет всех потомков для заданного списка ids_list на уровне административного деления.

get_admin_levels - Используется для построения иерархии регионов для заданного города. 
Функция получает информацию о городе из базы данных, а затем строит регионы.

get_regions - используется для получения всех регионов для заданного города.

list_to_polygon - преобразует список координат в многоугольник, который используется для построения графа дорог.

polygons_from_region - функция извлекает геометрические данные для каждого региона и объединяет их в единый полигон

graph_from_ids -  Она использует функцию polygons_from_region для создания полигона, на основе которого строится граф. Если функция polygons_from_region возвращает None, то graph_from_ids также возвращает None.

Функции point_obj_to_list, edge_obj_to_list, record_obj_to_wprop, record_obj_to_pprop используются для преобразования объектов базы данных в списки, которые используются для построения графа дорог.

graph_from_poly - функция использует переданный полигон, чтобы фильтровать множество точек и ребер, которые находятся внутри этого полигона, а затем строит граф, используя отфильтрованные точки и ребра.

Внутри функции определяется прямоугольник bbox, задающий границы по координатам широты и долготы города на карте. Затем выполняется запрос к базе данных для получения информации о городе. Если город не найден или не загружен, функция возвращает None.

Формируется SQL-запрос к базе данных для получения информации об узлах графа дорожной сети внутри заданного прямоугольника. Результат запроса представляется в виде списка из трех элементов: идентификатор узла, долгота и широта.

Выполняется еще один SQL-запрос к базе данных для получения информации о ребрах графа дорожной сети. Результат запроса представляется в виде списка из пяти элементов: идентификатор ребра, идентификатор дорожной полосы, идентификатор начального узла, идентификатор конечного узла и название дороги.

Выполняется фильтрация узлов и ребер графа, чтобы оставить только те, которые находятся внутри заданного полигона.

Формируются еще два SQL-запроса для получения информации о свойствах узлов и ребер графа. Результаты запросов сохраняются в виде списков points_prop и ways_prop.

Функция build_or_query используется для построения OR-запроса на основе  множества элементов, полученных из SQL-запросов.

Возвращает четыре списка: список узлов, список ребер, список свойств узлов и список свойств ребер:
        1) points	- список точек в виде id, longitude и latitude
        2) edges	- список ребер в виде  id, id_way, from, to и name
        3) points_prop	- список свойств точек в виде  id_point, property и value
        4) ways_prop	- список свойств дорог каждый из которых содержит id_way, property и value.

build_or_query - строит SQL-запрос для фильтрации по заданному полю и множеству значений. На входе принимает поле, по которому производится фильтрация, и значения, по которым нужно выполнить фильтрацию. Функция проходит по всем элементам множества и добавляет их к запросу в формате "поле = значение OR". Результат - строка, содержащая сформированный SQL-запрос.

filter_by_polygon - фильтрует список точек и ребер графа по заданному полигону. принимает полигон, список ребер и список точек графа. Функция проверяет каждую точку на принадлежность полигону и, если точка принадлежит, добавляет ее и ее идентификатор в множество points_ids и список points_filtred. Далее функция проверяет каждое ребро на принадлежность множеству точек points_ids и, если обе конечные точки ребра принадлежат множеству, добавляет ребро и идентификатор свойства в множество ways_prop_ids и список edges_filtred. Функция возвращает отфильтрованные списки точек и ребер, множество идентификаторов свойств ребер и множество идентификаторов точек, которые принадлежат полигону.

union_and_delete - принимает на вход граф и обрабатывает его, объединяя ребра, которые имеют общие узлы и атрибуты, указанные в переменной merging_col. После объединения она удаляет их из графа.

reverse_graph - создает новый граф, в котором ребра направлены в обратном направлении. Она также связывает узлы, которые пересекаются в исходном графе, создавая новые ребра в новом графе.

convert_to_df - преобразует граф в два фрейма данных: один для ребер и один для узлов.

get_reversed_graph - принимает на вход данные и преобразует их в граф с помощью функции nx.from_pandas_edgelist(). 
Затем она применяет функцию union_and_delete() для объединения ребер и удаления их из графа. 
Применяет функцию reverse_graph() для создания нового графа с обратными ребрами. 
Вызывает функцию convert_to_df() для преобразования нового графа в датафреймы и возвращает их в качестве результата.

### street_name_parser.py:
Данный код относится к задаче геокодирования адресов. Он принимает на вход список точек (WayNodeList) и для каждой точки находит ближайший адрес, используя API сервиса Dadata. Затем из найденного адреса извлекает название улицы или проезда с помощью регулярного выражения и возвращает его. Если для всех точек не удалось найти адреса, то возвращается символ '-'.

### Dockerfile:
Этот код содержит инструкции для создания образа Docker для запуска Python-приложения с помощью FastAPI.

### docker-compose.yaml:
Этот код описывает конфигурацию docker-compose для запуска нескольких сервисов:

postgres - контейнер с базой данных PostgreSQL, настроенной с определенным именем пользователя, паролем и именем базы данных.

webserver - контейнер с приложением FastAPI, связанный с базой данных Postgres. Он собирается из контекста api/ и имеет несколько томов, включая том для журналов, том для приложения и том для данных cities_osm. Контейнер перезапускается при необходимости и зависит от контейнера postgres.

frontend - контейнер с пользовательским интерфейсом Angular, который зависит от webserver. Он собирается из контекста ui/ и привязывает порт 4200 на локальном хосте к порту 4200 в контейнере.
Также определены два тома: pgdata для хранения данных PostgreSQL и logsvol для хранения журналов приложения FastAPI.

